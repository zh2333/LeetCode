Index: src/com/leetcode/utils/MyArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.leetcode.utils;\r\n\r\n/**\r\n * 面向数组的辅助测试类\r\n * @author zh\r\n *\r\n */\r\npublic class MyArray {\r\n\t\r\n\t/**\r\n\t * 生成一个二维数组\r\n\t * @param m\r\n\t * @param n\r\n\t * @return\r\n\t */\r\n\tpublic static int[][] generateTwoDimArray(int m, int n) {\r\n\t\tint[][] array = new int[m][n];\r\n\t\tfor(int i = 0; i < m;i++) {\r\n\t\t\tfor(int j = 0;j < n;j++) {\r\n\t\t\t\tarray[i][j] = (int)(Math.random() * 10);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\t/**\r\n\t * 生成一个一维数组\r\n\t * @param count\r\n\t * @return\r\n\t */\r\n\tpublic static int[] generateArray(int count) {\r\n\t\tint[] array = new int[count];\r\n\t\tfor(int i = 0; i < count;i++) {\r\n\t\t\tarray[i] = (int)(Math.random() * 10);\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\t/**\r\n\t * 打印一维数组\r\n\t * @param array\r\n\t */\r\n\tpublic static void printArray(int[] array) {\r\n\t\tSystem.out.print(\"[\");\r\n\t\tint len = array.length;\r\n\t\tfor (int i = 0; i < array.length; i++) {\r\n\t\t\tif(i == len - 1) {\r\n\t\t\t\tSystem.out.print(array[i]);\r\n\t\t\t} else {\r\n\t\t\t\tSystem.out.print(array[i] + \",\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\"]\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 打印二维数组\r\n\t * @param array\r\n\t */\r\n\tpublic static void printTwoDimArray(int[][] array) {\r\n\t\tSystem.out.println(\"{\");\r\n\t\tfor(int i = 0; i < array.length; i++) {\r\n\t\t\tSystem.out.print(\" {\");\r\n\t\t\tfor(int j = 0; j < array[0].length;j++) {\r\n\t\t\t\tif(j < array[0].length - 1){\r\n\t\t\t\t\tSystem.out.print(array[i][j] + \",\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tSystem.out.print(array[i][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSystem.out.println(\"},\");\r\n\t\t}\r\n\t\tSystem.out.println(\"}\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * 交换数组中的两个元素\r\n\t * @param Array\r\n\t * @param index1\r\n\t * @param index2\r\n\t */\r\n\tpublic static void swap(int[] Array, int index1, int index2) {\r\n\t\tint tmp = Array[index1];\r\n\t\tArray[index1] = Array[index2];\r\n\t\tArray[index2] = tmp;\r\n\t}\r\n\t\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/leetcode/utils/MyArray.java	(revision 0557d0581c6da3a727b031119225d69cc7c05acf)
+++ src/com/leetcode/utils/MyArray.java	(date 1603531068232)
@@ -1,5 +1,6 @@
 package com.leetcode.utils;
 
+import java.util.ArrayList;
 /**
  * 面向数组的辅助测试类
  * @author zh
@@ -82,5 +83,41 @@
 		Array[index1] = Array[index2];
 		Array[index2] = tmp;
 	}
+
+	/**
+	 * 将官方给的字符串测试用例转换成数组
+	 */
+	public static int[][] convertStrToArray(String str) {
+		int arrows = 0;
+		String sub = str.substring(1, str.length() - 1);
+		int len = sub.length();
+		ArrayList<String[]> res = new ArrayList<>();
+		int i = 0;
+		int j = 0;
+		while (i < len) {
+			String tmpStr = "";
+			if (sub.charAt(i) == '[') {
+				j = i;
+				while (sub.charAt(j) != ']') {
+					j++;
+				}
+			} else {
+				i++;
+				continue;
+			}
+			tmpStr = sub.substring(i + 1, j);
+			String[] arr = tmpStr.split(",");
+			res.add(arr);
+			arrows++;
+			i = j;
+		}
+		int[][] twoDimArray = new int[arrows][2];
+		for (int k = 0; k < arrows; k++) {
+			String[] arr = res.get(k);
+			twoDimArray[k][0] = Integer.valueOf(arr[0]);
+			twoDimArray[k][1] = Integer.valueOf(arr[1]);
+		}
+		return twoDimArray;
+	}
 	
 }
Index: src/com/leetcode/p1024/Solution.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/leetcode/p1024/Solution.java	(date 1603530773850)
+++ src/com/leetcode/p1024/Solution.java	(date 1603530773850)
@@ -0,0 +1,95 @@
+package com.leetcode.p1024;
+
+import com.leetcode.utils.MyArray;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+
+/**
+ * 你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。
+ *
+ * 视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。
+ *
+ * 我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。
+ *
+ *  
+ *
+ * 示例 1：
+ *
+ * 输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
+ * 输出：3
+ * 解释：
+ * 我们选中 [0,2], [8,10], [1,9] 这三个片段。
+ * 然后，按下面的方案重制比赛片段：
+ * 将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。
+ * 现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。
+ * 示例 2：
+ *
+ * 输入：clips = [[0,1],[1,2]], T = 5
+ * 输出：-1
+ * 解释：
+ * 我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。
+ * 示例 3：
+ *
+ * 输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
+ * 输出：3
+ * 解释：
+ * 我们选取片段 [0,4], [4,7] 和 [6,9] 。
+ * 示例 4：
+ *
+ * 输入：clips = [[0,4],[2,8]], T = 5
+ * 输出：2
+ * 解释：
+ * 注意，你可能录制超过比赛结束时间的视频。
+ *  
+ *
+ * 提示：
+ *
+ * 1 <= clips.length <= 100
+ * 0 <= clips[i][0] <= clips[i][1] <= 100
+ * 0 <= T <= 100
+ *
+ * 来源：力扣（LeetCode）
+ * 链接：https://leetcode-cn.com/problems/video-stitching
+ * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
+ */
+public class Solution {
+
+    @Test
+    public void test() {
+        int[][] arr = MyArray.convertStrToArray("[[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]]");
+        int res = videoStitching(arr, 9);
+        System.out.println(res);
+    }
+    public int videoStitching(int[][] clips, int T) {
+        if (clips == null) {
+            return 0;
+        }
+
+        int[] maxEnd = new int[T];  // 用于保存 以当前数字(下标)为起点 的区间的 最大的结束位置
+        
+        for (int[] clip : clips) {
+            if (clip[0] < T) {
+                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);
+            }
+        }
+
+        int pre = 0;    // 记录 结果中上一次的最大结束位置(本轮的最小开始位置)
+        int last = 0;   // 记录当前遍历到的 区间最大结束位置
+        int count = 0; // 记录结果
+        for (int i = 0; i < T; i++) {
+            last = Math.max(maxEnd[i], last);
+            if (i == last) {    // 当前元素 == 本区间最大元素(无法到达后续位置)
+                return -1;
+            }
+
+            if (i == pre) { // 当前元素 == 上一个区间的最大元素
+                count++;
+                pre = last;
+            }
+        }
+        return count;
+    }
+}
Index: src/com/leetcode/utils/Mytest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/leetcode/utils/Mytest.java	(date 1603530773852)
+++ src/com/leetcode/utils/Mytest.java	(date 1603530773852)
@@ -0,0 +1,49 @@
+package com.leetcode.utils;
+
+import org.junit.Test;
+
+import java.lang.reflect.Method;
+import java.util.concurrent.Executors;
+
+public class Mytest {
+    private String  className;
+    private String  methodname;
+    private Class<?> clazz;
+    private Object instance;
+
+    /**
+     * 初始化一个测试类
+     * @param className 测试方法所在类(包路径)
+     * @param methodname 测试方法方法名
+     */
+    public  Mytest(String  className, String  methodname) {
+        try {
+            this.className = className;
+            this.methodname = methodname;
+            this.clazz = Class.forName(this.className);//使用反射创建类对象
+            this.instance = clazz.getConstructor().newInstance();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * 运行测试
+     * @param args 测试方法参数
+     */
+    @Test
+    public void runTest(Object... args) {
+        try {
+            Class<?> clazz = this.clazz;
+            Object instance = this.instance;
+
+            for (Method classMethod: clazz.getMethods()) {
+                if (classMethod.getName().equals(this.methodname)) {
+                    classMethod.invoke(instance,args);//执行该类中的方法
+                }
+            }
+        }catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+}
Index: src/com/leetcode/p452/Solution.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/leetcode/p452/Solution.java	(date 1603530773852)
+++ src/com/leetcode/p452/Solution.java	(date 1603530773852)
@@ -0,0 +1,106 @@
+package com.leetcode.p452;
+
+
+import com.leetcode.utils.MyArray;
+import com.leetcode.utils.Mytest;
+import org.junit.Test;
+
+import java.util.Arrays;
+
+/**
+ * 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
+ *
+ * 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
+ *
+ * 给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
+ *
+ *  
+ * 示例 1：
+ *
+ * 输入：points = [[10,16],[2,8],[1,6],[7,12]]
+ * 输出：2
+ * 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
+ * 示例 2：
+ *
+ * 输入：points = [[1,2],[3,4],[5,6],[7,8]]
+ * 输出：4
+ * 示例 3：
+ *
+ * 输入：points = [[1,2],[2,3],[3,4],[4,5]]
+ * 输出：2
+ * 示例 4：
+ *
+ * 输入：points = [[1,2]]
+ * 输出：1
+ * 示例 5：
+ *
+ * 输入：points = [[2,3],[2,3]]
+ * 输出：1
+ *  
+ *
+ * 提示：
+ *
+ * 0 <= points.length <= 104
+ * points[i].length == 2
+ * -231 <= xstart < xend <= 231 - 1
+ *
+ * 来源：力扣（LeetCode）
+ * 链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons
+ * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
+ */
+public class Solution {
+
+    @Test
+    public void test() {
+        String str = "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]";
+        int[][] arr = MyArray.convertStrToArray(str);
+        int res = findMinArrowShots(arr);
+        System.out.println(res);
+
+    }
+    public int findMinArrowShots(int[][] points) {
+        int len = points.length;
+        if (len == 0 || len == 1) {
+            return len;
+        }
+        Arrays.sort(points, ((o1, o2) -> {
+            if (o1[0] == o2[0]) {
+                return o1[1] < o2[1] ? -1 : 1;
+            }
+            return o1[0] < o2[0] ? -1 : 1;
+        }));
+        MyArray.printTwoDimArray(points);
+        int[] shootArea = points[0];
+        int shoots = 1;
+        for (int i = 1; i < len ; i++) {
+            int[] intersection = getIntersection(shootArea, points[i]);
+            if (intersection == null) {//如果射击区间和新区间的交集为空, 意味着需要额外的一次射击, 并且要更新射击区间为新区间
+                shootArea = points[i];
+                shoots++;
+            } else {//射击区间和新区间有交集, 则不需要额外的射击次数, 射击区间更新为射击区间和新区间的交集, 射击次数不变
+                shootArea = intersection;
+            }
+        }
+        return shoots;
+    }
+
+    /**
+     * 获得两个数组的交集.传入的数组, arr1的左端点小于arr2的左端点
+     * @param arr1
+     * @param arr2
+     * @return
+     */
+    public int[] getIntersection(int[] arr1, int[] arr2) {
+        int[] intersection = new int[2];
+        if (arr1[1] >= arr2[0] && arr1[1] < arr2[1]) {
+            intersection[0] = arr2[0];
+            intersection[1] = arr1[1];
+            return  intersection;
+        } else if (arr1[1] >= arr2[1]){
+            intersection[0] = arr2[0];
+            intersection[1] = arr2[1];
+            return intersection;
+        }
+        return null;
+    }
+}
Index: src/com/leetcode/p198/Solution.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.leetcode.p198;\r\n\r\n\r\n/**\r\n * 动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )\r\n * \r\n * 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，\r\n * 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\r\n\t给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\r\n\t示例 1:\r\n\t输入: [1,2,3,1]\r\n\t输出: 4\r\n\t解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\r\n\t     偷窃到的最高金额 = 1 + 3 = 4 。\r\n * @author 张恒\r\n *\t\r\n *\t解决:\r\n *由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，\r\n *要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值\r\n\r\n */\r\npublic class Solution {\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tint[] test = {1,2,3,1};\r\n\t\tSystem.out.println(rob(test));\r\n\t}\r\n    public static int rob(int[] nums) {\r\n    \tint len = nums.length;\r\n    \tif(len == 0) return 0;\r\n    \t\r\n    \t//dp数组记录当前房屋可以盗的的最大金额\r\n    \tint[] dp = new int[len+1];\r\n    \tdp[0] = 0;\r\n    \tdp[1] = nums[0];\r\n    \t\r\n    \tfor (int i = 2; i <= len; i++) {\r\n\t\t\tdp[i] = Math.max(dp[i-1], dp[i-2]+nums[i-1]);\r\n\t\t}\r\n\t\treturn dp[len];\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/leetcode/p198/Solution.java	(revision 0557d0581c6da3a727b031119225d69cc7c05acf)
+++ src/com/leetcode/p198/Solution.java	(date 1603530773850)
@@ -22,7 +22,7 @@
 public class Solution {
 	
 	public static void main(String[] args) {
-		int[] test = {1,2,3,1};
+		int[] test = {1,2,3};
 		System.out.println(rob(test));
 	}
     public static int rob(int[] nums) {
Index: src/com/leetcode/p213/Solution.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/leetcode/p213/Solution.java	(date 1603530773851)
+++ src/com/leetcode/p213/Solution.java	(date 1603530773851)
@@ -0,0 +1,73 @@
+package com.leetcode.p213;
+
+
+import com.leetcode.utils.MyArray;
+import org.junit.Test;
+
+import java.util.Arrays;
+
+/**
+ * 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
+ * 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
+ * 示例 1:
+ * 输入: [2,3,2]
+ * 输出: 3
+ * 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
+ *
+ * 示例 2:
+ * 输入: [1,2,3,1]
+ * 输出: 4
+ * 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
+ *      偷窃到的最高金额 = 1 + 3 = 4 。
+ *
+ * 来源：力扣（LeetCode）
+ * 链接：https://leetcode-cn.com/problems/house-robber-ii
+ * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
+ */
+public class Solution {
+
+    @Test
+    public void test() {
+        int[] nums = {1,2,3,1};
+        int res = rob(nums);
+        System.out.println(res);
+    }
+
+    /**
+     * 环形数组意味着数组头和数组尾部不能同时被选中:
+     * 1. 头被选中, 尾部没有被选中
+     * 2. 头部没有被选中, 尾部被选中
+     * 3. 头部, 尾部均没有被选中
+     * 第三种情况是前两种情况的交集.因此只需要考虑前两种情况即可.
+     * 将环形数组拆分成两个数组: 0 ~ n-2  |  1 ~ n - 1;取两者中的最大值即可
+     * @param nums
+     * @return
+     */
+    public int rob(int[] nums) {
+        int len = nums.length;
+        if(len == 1) {
+            return nums[0];
+        } else if (len == 2){
+            return Math.max(nums[0], nums[1]);
+        }
+        int[] nums1 = Arrays.copyOfRange(nums, 0, len - 1);//[)左闭右开
+        MyArray.printArray(nums1);
+        int[] nums2 = Arrays.copyOfRange(nums, 1, len);
+        MyArray.printArray(nums2);
+        return Math.max(helper(nums1), helper(nums2));
+    }
+    public  int helper(int[] nums) {
+        int len = nums.length;
+        if(len == 0) return 0;
+
+        //dp数组记录当前房屋可以盗的的最大金额
+        int[] dp = new int[len+1];
+        dp[0] = 0;
+        dp[1] = nums[0];
+
+        for (int i = 2; i <= len; i++) {
+            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i-1]);
+        }
+        return dp[len];
+    }
+}
